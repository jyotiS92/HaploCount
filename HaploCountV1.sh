#!/bin/bash
# Script generated by Jyoti Sutar and Vainav Patel at Dept of Biochemistrty, National Institute for Research in Reproductive Health (ICMR), Mumbai, India
# Change logfile.log for redirecting the output to a different file
exec> >(tee logfile.log)
echo " "
while getopts "h?p:b:l:o:" args; do
case $args in
	h|\?)
		echo './HaploCountV1.sh -p paths.sh -b BAM_file -l RegionList.txt -o Output_TAG';
        exit;;
	p ) paths=${OPTARG};;
	b ) bam=${OPTARG};;
	l ) list=${OPTARG};;
	o ) outputtag=${OPTARG};;
	: )
	        echo "Missing option argument for -$OPTARG" >&2; exit 1;;
	*  )
		echo "Unimplemented option: -$OPTARG" >&2; exit 1;;
	esac
done
if [[ -z "$paths" ]]; then
	echo "-p [option] is required. Please specify a paths file"
	exit
fi
if [[ -z "$bam" ]]; then
	echo "-b [option] is required. Please specify a BAM file"
	exit
fi
if [[ -z "$list" ]]; then
	echo "-l [option] is required. Please specify a list file"
	exit
fi
if [[ -z "$outputtag" ]]; then
	echo "Output tag not specified. Analysis results will be redirected to a new directory "./Haplotypes""
	outputtag=Haplotypes	
fi

echo " "
echo "Pathfile to be used: $paths"
echo "listfile to be used: $list"
echo "BAM file to be used: $bam"
echo "Output directory:./$outputtag"
echo " "

source $paths

mkdir $outputtag

cat $list | awk 'FNR>1 {print$0}' | while read line; do
	E=`echo $line | awk '{print$1}'`
	echo "Epitope analysis initiated for $E"
	mkdir "$outputtag"_$E\_tmp		
	cd "$outputtag"_$E\_tmp
	regstart=`echo $line | awk '{print$2}'`
	regend=`echo $line | awk '{print$3}'`
	epitopeseq=`echo $line | awk '{print$4}'`
	epilength=${#epitopeseq}
	echo "Read statistics report generated for dataset "$outputtag":epitope $E" > ../$outputtag/"$outputtag"_ReadStats_$E\.txt
	header=`$samtools view -H ../$bam | wc -l`
#finding out read length and deciding upon the analysis window
	$samtools view -h ../$bam | awk -v header="$header" -v regstart="$regstart" -v regend="$regend" '(FNR <= header) || (($4 <= regstart) && (($4 + length($10)) >= regend))' | $samtools view -b -o "$outputtag"_$E.bam
	totalreads=`$samtools flagstat "$outputtag"_$E.bam | awk 'FNR==1{print $1}'`
	echo "# of reads that include the epitope: $totalreads" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
#fetching the reads from the bam file, tags for forward and reverse reads 
	$samtools view -f 0x20 "$outputtag"_$E.bam -o "$outputtag"_$E\_F.bam
	$samtools view -f 0x10 "$outputtag"_$E.bam -o "$outputtag"_$E\_R.bam
	$samtools view "$outputtag"_$E\_F.bam | awk '{printf("@%s\n%s\n+\n%s\n",$1,$10,$11)}' > "$outputtag"_$E\_F.fastq
	freads=`grep -c "^+" "$outputtag"_$E\_F.fastq`
	echo "# of forward reads: $freads" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
	$samtools view "$outputtag"_$E\_R.bam | awk '{printf("@%s\n%s\n+\n%s\n",$1,$10,$11)}' > "$outputtag"_$E\_R.fastq
	rreads=`grep -c "^+" "$outputtag"_$E\_R.fastq`
	echo "# of reverse reads: $rreads" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
# fastq filtration of forward reads based on quality, here phred quality of min 30 is selected for 95% of the read. -Q33 tag needs to be changed according to encoding of fastq files based on sequencing platform
	$fastqqf -q 30 -p 95 -i "$outputtag"_$E\_F.fastq -Q33 | paste - - - - | awk '{printf ("%s\n%s\n",$1,$2)}' | sed "s/@/>/g" > "$outputtag"_$E\_F.fasta
	freadsfilt=`grep -c ">" "$outputtag"_$E\_F.fasta`
	echo "# of forward reads post quality filtration: $freadsfilt" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
# fastq filtration of reverse reads based on quality, same as forward
	$fastqqf -q 30 -p 95 -i "$outputtag"_$E\_R.fastq -Q33 | paste - - - - | awk '{printf ("%s\n%s\n",$1,$2)}' | sed "s/@/>/g" > "$outputtag"_$E\_R.fasta
	rreadsfilt=`grep -c ">" "$outputtag"_$E\_R.fasta`
	echo "# of reverse reads post quality filtration: $rreadsfilt" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
	totalreadsfilt=$((freadsfilt+rreadsfilt))
	echo "# of reads post quality filtration: $totalreadsfilt" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
# translation of reads in all reading frames
	$transeq "$outputtag"_$E\_F.fasta "$outputtag"_$E\_F.pep -frame=F
	$transeq "$outputtag"_$E\_R.fasta "$outputtag"_$E\_R.pep -frame=F
	cat "$outputtag"_$E\_F.pep "$outputtag"_$E\_R.pep > "$outputtag"_$E.pep
	cat "$outputtag"_$E.pep | paste - - | awk '{printf ("%s_%s\n%s\n",$1,NR,$2)}' > "$outputtag"_$E\_AA.fasta
# fetching the list of correct reading frame based on hmm profile generated for region of interest. e.g. MPER being the region of gp41 gene of HIV-1, The profile was created from an alignment of 584 gp41 sequences from all subtypes. -o can be changed to --tblout to see the output in the terminal. Increases log file size. -E threshold can be changed by the user. 
	$hmmsearch -E 0.000001 -o "$outputtag"_$E\hmm $hmmprofile "$outputtag"_$E\_AA.fasta
	sed " /^#/ d" "$outputtag"_$E\hmm > "$outputtag"_$E\hmm2
	cat "$outputtag"_$E\hmm2 | awk '{printf(">%s\n",$1)}' > "$outputtag"_$E\_correctedFrames.txt
	cat "$outputtag"_$E\_AA.fasta | paste - - > "$outputtag"_$E\_AA.txt
# fetching the translated reads in the correct reading frame
	grep -Fwf "$outputtag"_$E\_correctedFrames.txt "$outputtag"_$E\_AA.txt | awk '{printf ("%s\n%s\n",$1,$2)}' > "$outputtag"_$E\_correctedframes.fasta
	readsfilt1=`grep -c ">" "$outputtag"_$E\_correctedframes.fasta`
	echo "# of reads remaining after translation and frame correction: $readsfilt1" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
# stop codons converted to U to retrieve the reads containing stop codons as well. * generates a lot of lines of error, a quick and dirty work-around. Needs to be modified to a better solution. Reads with stop codons can be entirely removed with sed if not required.
	sed -e "s/*/U/g" -e "s/X/-/g" "$outputtag"_$E\_correctedframes.fasta > "$outputtag"_$E\_correctedframes_cl.fasta
# increase gap open penalty to keep epitope sequences together, can be modified to suit different needs, -quiet flag can be removed to see stdout in log/terminal	
	$muscle -in "$outputtag"_$E\_correctedframes_cl.fasta -out "$outputtag"_$E\_aligned.fasta -maxiters 1 -diags -gapopen -30.0 -quiet 
# U characters (stop codons) are converted to X by muscle, converting them back to stop codons
	sed -e "s/X/*/g" "$outputtag"_$E\_aligned.fasta > "$outputtag"_$E\_aligned2.fasta
# extracting the correct part of epitope alignment
	pos=`cat "$outputtag"_$E\_aligned2.fasta | fasta_formatter -w 0 | grep $epitopeseq | head -n 1 | grep -bo $epitopeseq | awk -F ":" '{print $1}'`
	epistart=$((pos + 1))
	epiend=$((pos + epilength))
	$extractalign "$outputtag"_$E\_aligned2.fasta "$outputtag"_$E\_extracted.fasta -regions "$epistart-$epiend"
# Getting rid of sequences containing indels
	cat "$outputtag"_$E\_extracted.fasta | paste - - | sed -e " /-/ d" > "$outputtag"_$E\haplos.txt
	readsfilt2=`wc -l "$outputtag"_$E\haplos.txt | awk '{print$1}'`
	echo "# of reads covering the entire epitope: $readsfilt2" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
	filtthreshold1=`echo "$readsfilt1 $totalreadsfilt" | awk '{printf ("%.2f",($1-$2)*100/$2)}'`
	echo $filtthreshold1 >> "$outputtag"_$E\threshold
# here basic threshold is calculated per false positives generated by hmmer or 0.1% whichever higher. Further filtration can be performed later.
	filtthreshold2=`awk '{if ($1 > 0.1) print $1; else print "0.1";}' "$outputtag"_$E\threshold`
	echo "threshold for haplo filtration based on false positive reads: $filtthreshold2" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
	cat "$outputtag"_$E\haplos.txt | awk '{print $2}' | sort -k2 | uniq -c | sort -k1 -nr > "$outputtag"_$E\haplofreq.txt
	awk 'NR==FNR{sum+=$1; next}{printf ("%s\t%4.2f\n", $2,$1/sum*100)} ' "$outputtag"_$E\haplofreq.txt "$outputtag"_$E\haplofreq.txt > "$outputtag"_$E\haplofreq_percent.txt
	paste "$outputtag"_$E\haplofreq.txt "$outputtag"_$E\haplofreq_percent.txt >  "$outputtag"_$E\haplofreq_total.txt
	cat "$outputtag"_$E\haplofreq_total.txt | awk -v filtthreshold="$filtthreshold2" '{if ($4 >= filtthreshold) print $0}' > "$outputtag"_$E\haplofreq_total2.txt
	uniqhaplos1=`cat "$outputtag"_$E\haplofreq_total2.txt | wc -l`
	echo "# of unique haplotypes with frequency >$filtthreshold2 : $uniqhaplos1" >> ../$outputtag/"$outputtag"_ReadStats_$E\.txt
	cat "$outputtag"_$E\haplofreq_total2.txt | awk -v E="$E" ' BEGIN {print "Haplotype\tFrequency\t# of reads"} {printf ("%s\t%s\t%s\n",$2,$4,$1)}' > ../$outputtag/"$outputtag"_$E\_haplotypes_HC.txt
	echo "Epitope analysis completed for $E"
	cd ..
# Add the # sign to the following command in case you want to examine the intermediate files 
	rm -rf *_tmp/	
	echo " "
done
echo "Analysis completed for "$outputtag""
echo " "
cd ../


